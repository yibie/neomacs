/* Auto-generated by cbindgen. Do not edit. */
/* Neomacs Display Engine C FFI */


#ifndef NEOMACS_DISPLAY_H
#define NEOMACS_DISPLAY_H

/* Warning: this file was auto-generated by cbindgen. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
/**
 * Modifier flags matching Emacs.
 */
#define NEOMACS_SHIFT_MASK (1 << 0)

#define NEOMACS_CTRL_MASK (1 << 1)

#define NEOMACS_META_MASK (1 << 2)

#define NEOMACS_SUPER_MASK (1 << 3)

/**
 * Event kinds for NeomacsInputEvent.kind
 */
#define NEOMACS_EVENT_KEY_PRESS     1
#define NEOMACS_EVENT_KEY_RELEASE   2
#define NEOMACS_EVENT_MOUSE_PRESS   3
#define NEOMACS_EVENT_MOUSE_RELEASE 4
#define NEOMACS_EVENT_MOUSE_MOVE    5
#define NEOMACS_EVENT_SCROLL        6
#define NEOMACS_EVENT_RESIZE        7
#define NEOMACS_EVENT_CLOSE_REQUEST 8
#define NEOMACS_EVENT_FOCUS_IN      9
#define NEOMACS_EVENT_FOCUS_OUT     10

#define DRM_FORMAT_ARGB8888 875713089

#define DRM_FORMAT_XRGB8888 875713112

#define DRM_FORMAT_ABGR8888 875708993

#define DRM_FORMAT_XBGR8888 875709016


/**
 * Number of defined scroll effects.
 */
#define ScrollEffect_COUNT 21

/**
 * Modifier flags matching Emacs.
 */
#define NEOMACS_SHIFT_MASK (1 << 0)

#define NEOMACS_CTRL_MASK (1 << 1)

#define NEOMACS_META_MASK (1 << 2)

#define NEOMACS_SUPER_MASK (1 << 3)































/**
 * Maximum number of DMA-BUF planes supported.
 */
#define MAX_PLANES 4

#define DRM_FORMAT_ARGB8888 875713089

#define DRM_FORMAT_ARGB8888 875713089

#define DRM_FORMAT_XRGB8888 875713112

#define DRM_FORMAT_XRGB8888 875713112

#define DRM_FORMAT_ABGR8888 875708993

#define DRM_FORMAT_ABGR8888 875708993

#define DRM_FORMAT_XBGR8888 875709016

#define DRM_FORMAT_XBGR8888 875709016

#define DRM_FORMAT_RGBA8888 875708754

#define DRM_FORMAT_RGBX8888 875714642

#define DRM_FORMAT_BGRA8888 875708738

#define DRM_FORMAT_BGRX8888 875714626

#define DRM_FORMAT_NV12 842094158

#define DRM_FORMAT_YUV420 842093913

/**
 * Linear modifier (no tiling)
 */
#define DRM_FORMAT_MOD_LINEAR 0

/**
 * Invalid modifier
 */
#define DRM_FORMAT_MOD_INVALID 72057594037927935

#define VA_EXPORT_SURFACE_READ_ONLY 1

#define VA_EXPORT_SURFACE_SEPARATE_LAYERS 4

#define VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2 1073741824

/**
 * Popup menu item passed from C.
 */
typedef struct CPopupMenuItem {
  const char *label;
  const char *shortcut;
  int enabled;
  int separator;
  int submenu;
} CPopupMenuItem;

/**
 * Type for the resize callback function pointer from C
 */
typedef void (*ResizeCallbackFn)(void *user_data, int width, int height);

/**
 * Type for mouse button callback
 */
typedef void (*MouseButtonCallbackFn)(void *user_data,
                                      double x,
                                      double y,
                                      unsigned int button,
                                      int pressed,
                                      unsigned int modifiers,
                                      unsigned int time);

/**
 * Type for mouse motion callback
 */
typedef void (*MouseMotionCallbackFn)(void *user_data,
                                      double x,
                                      double y,
                                      unsigned int modifiers,
                                      unsigned int time);

/**
 * Type for mouse scroll callback
 */
typedef void (*MouseScrollCallbackFn)(void *user_data,
                                      double x,
                                      double y,
                                      double delta_x,
                                      double delta_y,
                                      unsigned int modifiers,
                                      unsigned int time);

/**
 * Input event structure passed to C.
 */
typedef struct NeomacsInputEvent {
  uint32_t kind;
  uint32_t windowId;
  uint64_t timestamp;
  int32_t x;
  int32_t y;
  uint32_t keycode;
  uint32_t keysym;
  uint32_t modifiers;
  uint32_t button;
  float scrollDeltaX;
  float scrollDeltaY;
  uint32_t width;
  uint32_t height;
} NeomacsInputEvent;

/**
 * Opaque pointer to an Emacs buffer (struct buffer *)
 */
typedef void *EmacsBuffer;

/**
 * Opaque pointer to an Emacs frame (struct frame *)
 */
typedef void *EmacsFrame;

/**
 * Opaque pointer to an Emacs window (struct window *)
 */
typedef void *EmacsWindow;

/**
 * FFI-safe window parameters struct.
 * Matches the C struct in neomacsterm.c.
 */
typedef struct WindowParamsFFI {
  /**
   * Window pointer as i64
   */
  int64_t windowId;
  /**
   * Buffer pointer as u64
   */
  uint64_t bufferId;
  /**
   * Window pointer (for FFI callbacks)
   */
  EmacsWindow windowPtr;
  /**
   * Buffer pointer (for FFI callbacks)
   */
  EmacsBuffer bufferPtr;
  /**
   * Frame-absolute position
   */
  float x;
  float y;
  float width;
  float height;
  /**
   * Text area bounds (excluding fringes, margins)
   */
  float textX;
  float textY;
  float textWidth;
  float textHeight;
  /**
   * Whether this is the selected window
   */
  int selected;
  /**
   * First visible buffer position
   */
  int64_t windowStart;
  /**
   * Point position
   */
  int64_t point;
  /**
   * Buffer size (ZV)
   */
  int64_t bufferZv;
  /**
   * Buffer beginning (BEGV)
   */
  int64_t bufferBegv;
  /**
   * Horizontal scroll
   */
  int hscroll;
  /**
   * Truncate long lines
   */
  int truncateLines;
  /**
   * Word wrap at word boundaries
   */
  int wordWrap;
  /**
   * Tab width
   */
  int tabWidth;
  /**
   * Default face colors (sRGB pixels)
   */
  uint32_t defaultFg;
  uint32_t defaultBg;
  /**
   * Character cell dimensions
   */
  float charWidth;
  float charHeight;
  /**
   * Font pixel size
   */
  float fontPixelSize;
  /**
   * Font ascent
   */
  float fontAscent;
  /**
   * Special line heights
   */
  float modeLineHeight;
  float headerLineHeight;
  float tabLineHeight;
  /**
   * Cursor type and width
   */
  uint8_t cursorType;
  int cursorBarWidth;
  /**
   * Fringe widths in pixels
   */
  float leftFringeWidth;
  float rightFringeWidth;
  /**
   * indicate-empty-lines: 0=off, 1=left, 2=right
   */
  int indicateEmptyLines;
  /**
   * show-trailing-whitespace
   */
  int showTrailingWhitespace;
  /**
   * trailing-whitespace face background color (sRGB pixel)
   */
  uint32_t trailingWsBg;
  /**
   * fill-column-indicator column (0 = off)
   */
  int fillColumnIndicator;
  /**
   * fill-column-indicator character (0 = use default '|')
   */
  int fillColumnIndicatorChar;
  /**
   * fill-column-indicator face foreground (sRGB pixel)
   */
  uint32_t fillColumnIndicatorFg;
  /**
   * Extra line spacing in pixels
   */
  float extraLineSpacing;
  /**
   * Whether to show cursor in non-selected windows
   */
  int cursorInNonSelected;
  /**
   * selective-display: 0=off, >0=hide lines indented more than N columns
   */
  int selectiveDisplay;
  /**
   * escape-glyph face foreground color for control chars
   */
  uint32_t escapeGlyphFg;
  /**
   * nobreak-char-display: 0=off, 1=highlight, 2=escape notation
   */
  int nobreakCharDisplay;
  /**
   * nobreak-char face foreground color
   */
  uint32_t nobreakCharFg;
  /**
   * glyphless-char face foreground color
   */
  uint32_t glyphlessCharFg;
  /**
   * wrap-prefix: string rendered at start of continuation lines
   */
  uint8_t wrapPrefix[128];
  int wrapPrefixLen;
  /**
   * line-prefix: string rendered at start of all visual lines
   */
  uint8_t linePrefix[128];
  int linePrefixLen;
  /**
   * Margin widths in pixels
   */
  float leftMarginWidth;
  float rightMarginWidth;
} WindowParamsFFI;

/**
 * FFI-safe face data struct.
 */
typedef struct FaceDataFFI {
  /**
   * Face ID
   */
  uint32_t faceId;
  /**
   * Foreground color (sRGB pixel: 0x00RRGGBB)
   */
  uint32_t fg;
  /**
   * Background color (sRGB pixel: 0x00RRGGBB)
   */
  uint32_t bg;
  /**
   * Font family name (null-terminated C string, valid for duration of layout)
   */
  const char *fontFamily;
  /**
   * Font weight (CSS scale: 400=normal, 700=bold)
   */
  int fontWeight;
  /**
   * Italic flag
   */
  int italic;
  /**
   * Font pixel size
   */
  int fontSize;
  /**
   * Underline style (0=none, 1=single, 2=wave, 3=double, 4=dotted, 5=dashed)
   */
  int underlineStyle;
  /**
   * Underline color (sRGB pixel)
   */
  uint32_t underlineColor;
  /**
   * Strike-through (0=none, 1=enabled)
   */
  int strikeThrough;
  /**
   * Strike-through color
   */
  uint32_t strikeThroughColor;
  /**
   * Overline (0=none, 1=enabled)
   */
  int overline;
  /**
   * Overline color
   */
  uint32_t overlineColor;
  /**
   * Box type (0=none, 1=line)
   */
  int boxType;
  /**
   * Box color
   */
  uint32_t boxColor;
  /**
   * Box line width
   */
  int boxLineWidth;
  /**
   * Extend: face bg extends to end of visual line (0=no, 1=yes)
   */
  int extend;
  /**
   * Per-face font character width (0.0 = use window default)
   */
  float fontCharWidth;
  /**
   * Per-face font ascent (0.0 = use window default)
   */
  float fontAscent;
} FaceDataFFI;

/**
 * FFI-safe line number configuration struct.
 * Matches the C struct LineNumberConfigFFI in neomacsterm.c.
 */
typedef struct LineNumberConfigFFI {
  /**
   * 0=off, 1=absolute, 2=relative, 3=visual
   */
  int mode;
  /**
   * Column width for line numbers (including padding)
   */
  int width;
  /**
   * display-line-numbers-offset
   */
  int offset;
  /**
   * display-line-numbers-major-tick
   */
  int majorTick;
  /**
   * display-line-numbers-minor-tick
   */
  int minorTick;
  /**
   * display-line-numbers-current-absolute
   */
  int currentAbsolute;
  /**
   * display-line-numbers-widen
   */
  int widen;
} LineNumberConfigFFI;

/**
 * FFI-safe display text property result.
 * Matches the C struct DisplayPropFFI in neomacsterm.c.
 */
typedef struct DisplayPropFFI {
  /**
   * 0=none, 1=string replacement, 2=space, 3=align-to, 4=image, 5=raise
   */
  int propType;
  /**
   * Bytes of replacement string (type=1)
   */
  int strLen;
  /**
   * Space width in columns (type=2)
   */
  float spaceWidth;
  /**
   * Space height in pixels (type=2), 0 = use default char_h
   */
  float spaceHeight;
  /**
   * Charpos where this display property region ends
   */
  int64_t coversTo;
  /**
   * Align-to column (type=3)
   */
  float alignTo;
  /**
   * GPU image ID (type=4)
   */
  uint32_t imageGpuId;
  /**
   * Image width in pixels (type=4)
   */
  int imageWidth;
  /**
   * Image height in pixels (type=4)
   */
  int imageHeight;
  /**
   * Image horizontal margin in pixels (type=4)
   */
  int imageHmargin;
  /**
   * Image vertical margin in pixels (type=4)
   */
  int imageVmargin;
  /**
   * Image ascent: 0-100 = percent, -1 = centered (type=4)
   */
  int imageAscent;
  /**
   * Raise factor (type=5), fraction of line height
   */
  float raiseFactor;
  /**
   * Display string face fg (type=1), 0=use position face
   */
  uint32_t displayFg;
  /**
   * Display string face bg (type=1), 0=use position face
   */
  uint32_t displayBg;
  /**
   * Fringe bitmap ID (type=6 left-fringe, type=7 right-fringe)
   */
  int fringeBitmapId;
  /**
   * Fringe face foreground color (type=6,7)
   */
  uint32_t fringeFg;
  /**
   * Fringe face background color (type=6,7)
   */
  uint32_t fringeBg;
  /**
   * Font height multiplier (type=5,8): 0.0=default, >0=scale factor
   */
  float heightFactor;
} DisplayPropFFI;

#define VA_STATUS_SUCCESS 0

#define VA_INVALID_SURFACE 4294967295

extern GMainContext *g_main_context_get_thread_default(void);

extern GMainContext *g_main_context_new(void);

extern GMainContext *g_main_context_ref(GMainContext *context);

extern void g_main_context_unref(GMainContext *context);

extern void g_main_context_push_thread_default(GMainContext *context);

extern void g_main_context_pop_thread_default(GMainContext *context);

extern int32_t g_main_context_acquire(GMainContext *context);

extern void g_main_context_release(GMainContext *context);

extern GObject *g_object_new(GType objectType, const char *firstPropertyName, ...);

/**
 * Shutdown the display engine
 *
 * # Safety
 * The handle must have been returned by neomacs_display_init_threaded.
 */
void neomacs_display_shutdown(struct NeomacsDisplay *handle);

/**
 * Resize the display
 */
void neomacs_display_resize(struct NeomacsDisplay *handle, int width, int height);

/**
 * Begin building a new frame
 */
void neomacs_display_begin_frame(struct NeomacsDisplay *handle);

/**
 * Add a window to the current frame
 */
void neomacs_display_add_window(struct NeomacsDisplay *handle,
                                int windowId,
                                float x,
                                float y,
                                float width,
                                float height,
                                uint32_t bgColor,
                                int selected);

/**
 * Add per-window metadata for animation detection
 */
void neomacs_display_add_window_info(struct NeomacsDisplay *handle,
                                     int64_t windowId,
                                     uint64_t bufferId,
                                     int64_t windowStart,
                                     float x,
                                     float y,
                                     float width,
                                     float height,
                                     float modeLineHeight,
                                     int selected);

/**
 * Set cursor for a specific window
 */
void neomacs_display_set_cursor(struct NeomacsDisplay *handle,
                                int windowId,
                                float x,
                                float y,
                                float width,
                                float height,
                                int style,
                                uint32_t color,
                                int visible);

/**
 * Set inverse video info for a filled box cursor
 *
 * Called from C for style 0 (filled box) cursors. Provides the cursor
 * background color (the cursor rect) and cursor foreground color (for
 * redrawing the character under the cursor in inverse video).
 */
void neomacs_display_set_cursor_inverse(struct NeomacsDisplay *handle,
                                        float x,
                                        float y,
                                        float width,
                                        float height,
                                        uint32_t cursorBgRgba,
                                        uint32_t cursorFgRgba);

/**
 * Draw a border rectangle (for window dividers)
 */
void neomacs_display_draw_border(struct NeomacsDisplay *handle,
                                 int x,
                                 int y,
                                 int width,
                                 int height,
                                 uint32_t color);

/**
 * Add a GPU-rendered scroll bar
 */
void neomacs_display_add_scroll_bar(struct NeomacsDisplay *handle,
                                    int horizontal,
                                    int x,
                                    int y,
                                    int width,
                                    int height,
                                    int thumbStart,
                                    int thumbSize,
                                    uint32_t trackColor,
                                    uint32_t thumbColor);

/**
 * Begin a new glyph row for the current window
 */
void neomacs_display_begin_row(struct NeomacsDisplay *handle,
                               int y,
                               int x,
                               int height,
                               int ascent,
                               int modeLine,
                               int headerLine);

/**
 * Add a character glyph to the current row
 */
void neomacs_display_add_char_glyph(struct NeomacsDisplay *handle,
                                    uint32_t charcode,
                                    uint32_t faceId,
                                    int pixelWidth,
                                    int ascent,
                                    int descent);

/**
 * Add a stretch (whitespace) glyph to the current row
 */
void neomacs_display_add_stretch_glyph(struct NeomacsDisplay *handle,
                                       int pixelWidth,
                                       int height,
                                       uint32_t faceId);

/**
 * Add an image glyph to the current row
 */
void neomacs_display_add_image_glyph(struct NeomacsDisplay *handle,
                                     uint32_t imageId,
                                     int pixelWidth,
                                     int pixelHeight);

/**
 * End the current row
 */
void neomacs_display_end_row(struct NeomacsDisplay *handle);

/**
 * Register or update a face
 * Colors are in 0xRRGGBB format
 */
void neomacs_display_set_face(struct NeomacsDisplay *handle,
                              uint32_t faceId,
                              uint32_t foreground,
                              uint32_t background,
                              const char *fontFamily,
                              uint16_t fontWeight,
                              int isItalic,
                              int fontSize,
                              int underlineStyle,
                              uint32_t underlineColor,
                              int boxType,
                              uint32_t boxColor,
                              int boxLineWidth,
                              int boxCornerRadius,
                              int strikeThrough,
                              uint32_t strikeThroughColor,
                              int overline,
                              uint32_t overlineColor,
                              int fontAscent,
                              int fontDescent,
                              int ulPosition,
                              int ulThickness);

/**
 * Set the frame/scene background color
 * Color is in 0xRRGGBB format
 */
void neomacs_display_set_background(struct NeomacsDisplay *handle, uint32_t color);

/**
 * Set the frame/scene background alpha (for transparent backgrounds).
 * alpha is 0.0 (fully transparent) to 1.0 (fully opaque).
 */
void neomacs_display_set_background_alpha(struct NeomacsDisplay *handle, float alpha);

/**
 * Add a video glyph to the current row
 */
void neomacs_display_add_video_glyph(struct NeomacsDisplay *handle,
                                     uint32_t videoId,
                                     int pixelWidth,
                                     int pixelHeight);

/**
 * Load a video from file path (async - uses GStreamer)
 */
uint32_t neomacs_display_load_video(struct NeomacsDisplay *handle, const char *path);

/**
 * Play a loaded video
 */
int neomacs_display_video_play(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Pause a video
 */
int neomacs_display_video_pause(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Stop a video
 */
int neomacs_display_video_stop(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Set video loop mode (-1 for infinite)
 */
int neomacs_display_video_set_loop(struct NeomacsDisplay *handle, uint32_t videoId, int loopCount);

/**
 * Process pending video frames (call each frame)
 */
int neomacs_display_video_update(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Get video dimensions (works for pending and loaded videos)
 */
int neomacs_display_get_video_size(struct NeomacsDisplay *handle,
                                   uint32_t videoId,
                                   int *width,
                                   int *height);

/**
 * Load an image from a file path (delegates to load_image_file)
 */
uint32_t neomacs_display_load_image(struct NeomacsDisplay *handle, const char *path);

/**
 * Load an image from raw bytes (encoded image format)
 */
uint32_t neomacs_display_load_image_data(struct NeomacsDisplay *handle,
                                         const uint8_t *data,
                                         uintptr_t len);

/**
 * Load an image from raw bytes with optional scaling
 */
uint32_t neomacs_display_load_image_data_scaled(struct NeomacsDisplay *handle,
                                                const uint8_t *data,
                                                uintptr_t len,
                                                int maxWidth,
                                                int maxHeight);

/**
 * Load an image from raw ARGB32 pixel data
 */
uint32_t neomacs_display_load_image_argb32(struct NeomacsDisplay *handle,
                                           const uint8_t *data,
                                           int width,
                                           int height,
                                           int stride);

/**
 * Load an image from raw RGB24 pixel data
 */
uint32_t neomacs_display_load_image_rgb24(struct NeomacsDisplay *handle,
                                          const uint8_t *data,
                                          int width,
                                          int height,
                                          int stride);

/**
 * Load an image from a file path (async - returns ID immediately)
 */
uint32_t neomacs_display_load_image_file(struct NeomacsDisplay *handle, const char *path);

/**
 * Load an image from a file path with scaling (async)
 */
uint32_t neomacs_display_load_image_file_scaled(struct NeomacsDisplay *handle,
                                                const char *path,
                                                int maxWidth,
                                                int maxHeight);

/**
 * Load an image directly as texture (same as load_image_file)
 */
uint32_t neomacs_display_load_image_file_direct(struct NeomacsDisplay *handle, const char *path);

/**
 * Load an image directly as texture with scaling
 */
uint32_t neomacs_display_load_image_file_direct_scaled(struct NeomacsDisplay *handle,
                                                       const char *path,
                                                       int maxWidth,
                                                       int maxHeight);

/**
 * Get image dimensions (works for pending and loaded images)
 */
int neomacs_display_get_image_size(struct NeomacsDisplay *handle,
                                   uint32_t imageId,
                                   int *width,
                                   int *height);

/**
 * Query image file dimensions without loading (fast - reads header only)
 */
int neomacs_display_query_image_file_size(struct NeomacsDisplay *handle,
                                          const char *path,
                                          int *width,
                                          int *height);

/**
 * Free an image from cache
 */
int neomacs_display_free_image(struct NeomacsDisplay *handle, uint32_t imageId);

/**
 * Set a floating video at a specific screen position
 */
void neomacs_display_set_floating_video(struct NeomacsDisplay *handle,
                                        uint32_t videoId,
                                        int x,
                                        int y,
                                        int width,
                                        int height);

/**
 * Remove a floating video
 */
void neomacs_display_clear_floating_video(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Set a floating image at a specific screen position
 */
void neomacs_display_set_floating_image(struct NeomacsDisplay *handle,
                                        uint32_t imageId,
                                        int x,
                                        int y,
                                        int width,
                                        int height);

/**
 * Remove a floating image
 */
void neomacs_display_clear_floating_image(struct NeomacsDisplay *handle, uint32_t imageId);

/**
 * Clear a rectangular area of the display
 */
void neomacs_display_clear_area(struct NeomacsDisplay *handle, int x, int y, int width, int height);

/**
 * Clear only media glyphs (Image, Video, WebKit) in a rectangular area.
 * Called at the start of update_window_begin to clear stale media glyphs
 * before Emacs sends new positions.
 */
void neomacs_display_clear_media_in_area(struct NeomacsDisplay *handle,
                                         int x,
                                         int y,
                                         int width,
                                         int height);

/**
 * Clear all glyphs - used when frame layout changes
 */
void neomacs_display_clear_all_glyphs(struct NeomacsDisplay *handle);

/**
 * Clear all cursors
 */
void neomacs_display_clear_all_cursors(struct NeomacsDisplay *handle);

/**
 * Clear all borders (window dividers)
 */
void neomacs_display_clear_all_borders(struct NeomacsDisplay *handle);

/**
 * End frame and render
 * Returns 0 on success, 1 if layout changed, -1 on error
 */
int neomacs_display_end_frame(struct NeomacsDisplay *handle);

/**
 * Render the scene to an external Cairo context (stub)
 */
int neomacs_display_render_to_cairo(struct NeomacsDisplay *handle, void *cairoContext);

/**
 * Initialize the renderer with a Pango context (stub)
 */
void neomacs_display_init_pango(struct NeomacsDisplay *handle, void *pangoContext);

/**
 * Enable or disable GSK rendering (stub)
 */
void neomacs_display_set_gsk_enabled(struct NeomacsDisplay *handle, int enabled);

/**
 * Start smooth scroll animation
 */
void neomacs_display_smooth_scroll(struct NeomacsDisplay *handle,
                                   int windowId,
                                   float fromOffset,
                                   float toOffset);

/**
 * Reset cursor blink (call when cursor moves)
 */
void neomacs_display_reset_cursor_blink(struct NeomacsDisplay *handle);

/**
 * Set mouse pointer cursor shape.
 * Types: 0=hidden, 1=default/arrow, 2=text/ibeam, 3=hand/pointer,
 *        4=crosshair, 5=h-resize, 6=v-resize, 7=hourglass,
 *        8=nwse-resize, 9=nesw-resize, 10=nesw-resize, 11=nwse-resize
 */
void neomacs_display_set_mouse_cursor(struct NeomacsDisplay *handle, int cursorType);

/**
 * Warp (move) the mouse pointer to the given pixel position.
 */
void neomacs_display_warp_mouse(struct NeomacsDisplay *handle, int x, int y);

/**
 * Show a popup menu at position (x, y) with the given items.
 * The render thread will display the menu and send a MenuSelection event.
 */
void neomacs_display_show_popup_menu(struct NeomacsDisplay *handle,
                                     int x,
                                     int y,
                                     const struct CPopupMenuItem *items,
                                     int itemCount,
                                     const char *title,
                                     uint32_t fgColor,
                                     uint32_t bgColor);

/**
 * Hide the active popup menu.
 */
void neomacs_display_hide_popup_menu(struct NeomacsDisplay *handle);

/**
 * Show a tooltip at the given position with specified colors.
 */
void neomacs_display_show_tooltip(struct NeomacsDisplay *handle,
                                  float x,
                                  float y,
                                  const char *text,
                                  float fgR,
                                  float fgG,
                                  float fgB,
                                  float bgR,
                                  float bgG,
                                  float bgB);

/**
 * Hide the active tooltip.
 */
void neomacs_display_hide_tooltip(struct NeomacsDisplay *handle);

/**
 * Trigger visual bell flash effect.
 */
void neomacs_display_visual_bell(struct NeomacsDisplay *handle);

/**
 * Set the window title (threaded mode)
 */
void neomacs_display_set_title(struct NeomacsDisplay *handle, const char *title);

/**
 * Set fullscreen mode (threaded mode)
 * mode: 0=none, 1=width, 2=height, 3=both, 4=maximized
 */
void neomacs_display_set_fullscreen(struct NeomacsDisplay *handle, int mode);

/**
 * Minimize/iconify the window (threaded mode)
 */
void neomacs_display_set_minimized(struct NeomacsDisplay *handle, int minimized);

/**
 * Set window position (threaded mode)
 */
void neomacs_display_set_position(struct NeomacsDisplay *handle, int x, int y);

/**
 * Request window inner size change (threaded mode)
 */
void neomacs_display_request_size(struct NeomacsDisplay *handle, int width, int height);

/**
 * Set window decorations (threaded mode)
 */
void neomacs_display_set_decorated(struct NeomacsDisplay *handle, int decorated);

/**
 * Configure cursor blinking (enable/disable and interval)
 */
void neomacs_display_set_cursor_blink(struct NeomacsDisplay *handle, int enabled, int intervalMs);

/**
 * Configure cursor animation (smooth motion)
 */
void neomacs_display_set_cursor_animation(struct NeomacsDisplay *handle, int enabled, float speed);

/**
 * Configure all animation settings
 */
void neomacs_display_set_animation_config(struct NeomacsDisplay *handle,
                                          int cursorEnabled,
                                          float cursorSpeed,
                                          uint8_t cursorStyle,
                                          uint32_t cursorDurationMs,
                                          int crossfadeEnabled,
                                          uint32_t crossfadeDurationMs,
                                          int scrollEnabled,
                                          uint32_t scrollDurationMs,
                                          uint32_t scrollEffect,
                                          uint32_t scrollEasing,
                                          float trailSize,
                                          uint32_t crossfadeEffect,
                                          uint32_t crossfadeEasing);

/**
 * Check if animations are active
 */
int neomacs_display_has_animations(struct NeomacsDisplay *handle);

/**
 * Get backend name
 */
const char *neomacs_display_backend_name(struct NeomacsDisplay *handle);

/**
 * Check if backend is initialized
 */
int neomacs_display_is_initialized(struct NeomacsDisplay *handle);

/**
 * Create a GPU-accelerated NeomacsWidget (stub)
 */
void *neomacs_display_create_widget(void);

/**
 * Set the scene on a NeomacsWidget (stub)
 */
int neomacs_display_widget_set_scene(struct NeomacsDisplay *handle, void *widget);

/**
 * Initialize the GSK renderer's Pango context from a NeomacsWidget (stub)
 */
void neomacs_display_widget_init_pango(struct NeomacsDisplay *handle, void *widget);

/**
 * Render scene to a NeomacsWidget (stub)
 */
int neomacs_display_render_to_widget(struct NeomacsDisplay *handle, void *widget);

/**
 * Set the resize callback for winit windows.
 *
 * The callback will be invoked when the window is resized.
 */
void neomacs_display_set_resize_callback(ResizeCallbackFn callback, void *userData);

/**
 * Set the mouse button callback (stub)
 */
void neomacs_display_set_mouse_button_callback(MouseButtonCallbackFn callback, void *userData);

/**
 * Set the mouse motion callback (stub)
 */
void neomacs_display_set_mouse_motion_callback(MouseMotionCallbackFn callback, void *userData);

/**
 * Set the mouse scroll callback (stub)
 */
void neomacs_display_set_mouse_scroll_callback(MouseScrollCallbackFn callback, void *userData);

/**
 * Create a new terminal.
 *
 * Returns terminal ID (>0 on success, 0 on failure).
 * `mode`: 0=Window, 1=Inline, 2=Floating
 * `shell`: optional shell path (NULL for default)
 */
uint32_t neomacs_display_terminal_create(uint16_t cols,
                                         uint16_t rows,
                                         uint8_t mode,
                                         const char *shell);

/**
 * Write input data to a terminal (keyboard input from user).
 */
void neomacs_display_terminal_write(uint32_t terminalId, const uint8_t *data, uintptr_t len);

/**
 * Resize a terminal.
 */
void neomacs_display_terminal_resize(uint32_t terminalId, uint16_t cols, uint16_t rows);

/**
 * Destroy a terminal.
 */
void neomacs_display_terminal_destroy(uint32_t terminalId);

/**
 * Set floating terminal position and opacity.
 */
void neomacs_display_terminal_set_float(uint32_t terminalId, float x, float y, float opacity);

/**
 * Get visible text from a terminal.
 *
 * Returns a malloc'd C string (caller must free with `free()`).
 * Returns NULL on failure.
 */
char *neomacs_display_terminal_get_text(uint32_t terminalId);

/**
 * Set callback for WebKit new window/tab requests
 */
void neomacs_display_webkit_set_new_window_callback(bool (*callback)(uint32_t,
                                                                     const char*,
                                                                     const char*));

/**
 * Set callback for WebKit page load events
 */
void neomacs_display_webkit_set_load_callback(void (*callback)(uint32_t, int, const char*));

/**
 * Initialize WebKit subsystem with EGL display
 */
int neomacs_display_webkit_init(struct NeomacsDisplay *handle, void *eglDisplay);

/**
 * Create a new WebKit view (threaded mode only)
 */
uint32_t neomacs_display_webkit_create(struct NeomacsDisplay *handle, int width, int height);

/**
 * Destroy a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_destroy(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Load a URI in a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_load_uri(struct NeomacsDisplay *handle,
                                    uint32_t viewId,
                                    const char *uri);

/**
 * Go back in a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_go_back(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Go forward in a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_go_forward(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Reload a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_reload(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Resize a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_resize(struct NeomacsDisplay *handle,
                                  uint32_t viewId,
                                  int width,
                                  int height);

/**
 * Execute JavaScript in a WebKit view (threaded mode only)
 */
int neomacs_display_webkit_execute_js(struct NeomacsDisplay *handle,
                                      uint32_t viewId,
                                      const char *script);

/**
 * Set a floating WebKit view position and size
 */
void neomacs_display_set_floating_webkit(struct NeomacsDisplay *handle,
                                         uint32_t webkitId,
                                         int x,
                                         int y,
                                         int width,
                                         int height);

/**
 * Hide a floating WebKit view
 */
void neomacs_display_hide_floating_webkit(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Find which webkit view (floating or inline) is at the given coordinates
 */
int neomacs_display_webkit_at_position(struct NeomacsDisplay *handle,
                                       int x,
                                       int y,
                                       uint32_t *outWebkitId,
                                       int *outRelX,
                                       int *outRelY);

/**
 * Send keyboard event to WebKit view (threaded mode only)
 */
void neomacs_display_webkit_send_key(struct NeomacsDisplay *handle,
                                     uint32_t webkitId,
                                     uint32_t keyCode,
                                     uint32_t hardwareKeyCode,
                                     int pressed,
                                     uint32_t modifiers);

/**
 * Send pointer/mouse event to WebKit view (threaded mode only)
 */
void neomacs_display_webkit_send_pointer(struct NeomacsDisplay *handle,
                                         uint32_t webkitId,
                                         uint32_t eventType,
                                         int x,
                                         int y,
                                         uint32_t button,
                                         uint32_t state,
                                         uint32_t modifiers);

/**
 * Send scroll event to WebKit view (threaded mode only)
 */
void neomacs_display_webkit_send_scroll(struct NeomacsDisplay *handle,
                                        uint32_t webkitId,
                                        int x,
                                        int y,
                                        int deltaX,
                                        int deltaY);

/**
 * Click in WebKit view (threaded mode only)
 */
void neomacs_display_webkit_click(struct NeomacsDisplay *handle,
                                  uint32_t webkitId,
                                  int x,
                                  int y,
                                  uint32_t button);

/**
 * Scroll blit pixels in the pixel buffer (threaded mode only)
 *
 * This performs a GPU blit operation within the pixel buffer, copying pixels
 * from one vertical position to another. Used to implement Emacs's scroll_run_hook.
 *
 * Parameters:
 * - x, y: top-left corner of the region to scroll
 * - width, height: size of the region
 * - from_y, to_y: source and destination Y positions for the scroll
 * - bg_r, bg_g, bg_b: background color (0.0-1.0) to fill exposed region
 */
void neomacs_display_scroll_blit(struct NeomacsDisplay *handle,
                                 int x,
                                 int y,
                                 int width,
                                 int height,
                                 int fromY,
                                 int toY,
                                 float bgR,
                                 float bgG,
                                 float bgB);

/**
 * Get WebKit view title
 * NOTE: In threaded mode, title changes are delivered via InputEvent::WebKitTitleChanged.
 * This function returns null - use the callback-based API instead.
 */
char *neomacs_display_webkit_get_title(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Get WebKit view URL
 * NOTE: In threaded mode, URL changes are delivered via InputEvent::WebKitUrlChanged.
 * This function returns null - use the callback-based API instead.
 */
char *neomacs_display_webkit_get_url(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Get WebKit view loading progress
 * NOTE: In threaded mode, progress changes are delivered via InputEvent::WebKitProgressChanged.
 * This function returns -1.0 - use the callback-based API instead.
 */
double neomacs_display_webkit_get_progress(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Check if WebKit view is loading
 * NOTE: In threaded mode, loading state is inferred from progress events.
 * This function returns -1 (unknown) - use progress callbacks instead.
 */
int neomacs_display_webkit_is_loading(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Free a string returned by webkit_get_title or webkit_get_url
 */
void neomacs_display_webkit_free_string(char *s);

/**
 * Update WebKit view - no-op in threaded mode
 * In threaded mode, GLib main context is pumped automatically on the render thread.
 */
int neomacs_display_webkit_update(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Update all WebKit views - no-op in threaded mode
 * In threaded mode, GLib main context is pumped automatically on the render thread.
 */
int neomacs_display_webkit_update_all(struct NeomacsDisplay *handle);

/**
 * Add a WPE glyph to the current row
 */
void neomacs_display_add_wpe_glyph(struct NeomacsDisplay *handle,
                                   uint32_t viewId,
                                   int pixelWidth,
                                   int pixelHeight);

/**
 * Create a new window with the specified dimensions and title.
 *
 * Returns the window ID. The window will be created during the next poll_events call.
 * Returns 0 if the backend is not available.
 */
uint32_t neomacs_display_create_window(struct NeomacsDisplay *handle,
                                       int32_t width,
                                       int32_t height,
                                       const char *title);

/**
 * Destroy a window by its ID.
 */
void neomacs_display_destroy_window(struct NeomacsDisplay *handle, uint32_t windowId);

/**
 * Show or hide a window.
 */
void neomacs_display_show_window(struct NeomacsDisplay *handle, uint32_t windowId, bool visible);

/**
 * Set the title of a window.
 */
void neomacs_display_set_window_title(struct NeomacsDisplay *handle,
                                      uint32_t windowId,
                                      const char *title);

/**
 * Set the size of a window.
 */
void neomacs_display_set_window_size(struct NeomacsDisplay *handle,
                                     uint32_t windowId,
                                     int32_t width,
                                     int32_t height);

/**
 * Begin a frame for a specific window.
 *
 * Clears the window's scene to prepare for new content.
 */
void neomacs_display_begin_frame_window(struct NeomacsDisplay *handle,
                                        uint32_t windowId,
                                        float charWidth,
                                        float charHeight,
                                        float fontPixelSize);

/**
 * End a frame for a specific window and present it.
 *
 * Renders the window's scene to its surface and presents it.
 */
void neomacs_display_end_frame_window(struct NeomacsDisplay *handle, uint32_t windowId);

/**
 * Called from C when `neomacs-use-rust-display` is enabled.
 * The Rust layout engine reads buffer data via FFI helpers and produces
 * a FrameGlyphBuffer, bypassing the C matrix extraction.
 *
 * # Safety
 * Must be called on the Emacs thread. All pointers must be valid.
 */
void neomacs_rust_layout_frame(struct NeomacsDisplay *handle,
                               void *framePtr,
                               float width,
                               float height,
                               float charWidth,
                               float charHeight,
                               float fontPixelSize,
                               uint32_t background,
                               uint32_t verticalBorderFg,
                               int32_t rightDividerWidth,
                               int32_t bottomDividerWidth,
                               uint32_t dividerFg,
                               uint32_t dividerFirstFg,
                               uint32_t dividerLastFg);

/**
 * Set an animation configuration option (stub)
 */
int neomacs_display_set_animation_option(struct NeomacsDisplay *handle,
                                         const char *key,
                                         const char *value);

/**
 * Get an animation configuration option (stub)
 */
char *neomacs_display_get_animation_option(struct NeomacsDisplay *handle, const char *key);

/**
 * Free a string returned by neomacs_display_get_animation_option
 */
void neomacs_display_free_string(char *s);

/**
 * Update cursor animation state (stub)
 */
int neomacs_display_update_animation(struct NeomacsDisplay *handle, double dt);

/**
 * Check if animation needs continuous redraw (stub)
 */
int neomacs_display_animation_active(struct NeomacsDisplay *handle);

/**
 * Trigger a buffer transition animation (stub)
 */
int neomacs_display_start_buffer_transition(struct NeomacsDisplay *handle,
                                            const char *effect,
                                            int durationMs);

/**
 * Prepare for buffer transition (stub)
 */
int neomacs_display_prepare_buffer_transition(struct NeomacsDisplay *handle);

/**
 * Trigger buffer transition animation (stub)
 */
int neomacs_display_trigger_buffer_transition(struct NeomacsDisplay *handle);

/**
 * Check if buffer transition is ready (stub)
 */
int neomacs_display_has_transition_snapshot(struct NeomacsDisplay *handle);

/**
 * Initialize display in threaded mode
 *
 * Returns the wakeup pipe fd that Emacs should select() on,
 * or -1 on error.
 */
int neomacs_display_init_threaded(uint32_t width, uint32_t height, const char *title);

/**
 * Drain input events from render thread
 *
 * Returns number of events written to buffer.
 */
int neomacs_display_drain_input(struct NeomacsInputEvent *events, int maxEvents);

/**
 * Get the next batch of dropped file paths.
 * Returns the number of paths written.  Each path is a null-terminated
 * C string that must be freed with `neomacs_clipboard_free_text`.
 * Call repeatedly until it returns 0 to drain all pending drops.
 */
int neomacs_display_get_dropped_files(char **outPaths, int maxPaths);

/**
 * Free a string returned by `neomacs_display_get_dropped_files`.
 */
void neomacs_display_free_dropped_path(char *path);

/**
 * Get the terminal title from the most recent title change event.
 * Returns a C string that must be freed with
 * `neomacs_display_free_dropped_path` (same allocator), or NULL.
 */
char *neomacs_display_get_terminal_title(uint32_t terminalId);

/**
 * Send frame glyphs to render thread
 */
void neomacs_display_send_frame(struct NeomacsDisplay *handle);

/**
 * Send command to render thread
 */
void neomacs_display_send_command(int cmdType,
                                  uint32_t id,
                                  uint32_t param1,
                                  uint32_t param2,
                                  const char *strParam);

/**
 * Shutdown threaded display
 */
void neomacs_display_shutdown_threaded(void);

/**
 * Get wakeup fd for threaded mode (for Emacs to select() on)
 */
int neomacs_display_get_threaded_wakeup_fd(void);

/**
 * Get display handle for threaded mode
 *
 * Returns the NeomacsDisplay handle for use with frame operations.
 * Returns NULL if threaded mode is not initialized.
 */
struct NeomacsDisplay *neomacs_display_get_threaded_handle(void);

/**
 * Set clipboard text.  The text is a UTF-8 C string.
 * Returns 0 on success, -1 on failure.
 */
int neomacs_clipboard_set_text(const char *text);

/**
 * Get clipboard text.  Returns a newly allocated UTF-8 C string
 * that the caller must free with neomacs_clipboard_free_text(),
 * or NULL if the clipboard is empty or an error occurred.
 */
char *neomacs_clipboard_get_text(void);

/**
 * Free a string returned by neomacs_clipboard_get_text().
 */
void neomacs_clipboard_free_text(char *text);

/**
 * Get a byte from buffer text at the given byte position.
 * Handles the gap buffer transparently.
 * Returns -1 if pos is out of range.
 */
extern int neomacs_layout_buffer_byte_at(EmacsBuffer buffer, int64_t bytePos);

/**
 * Copy buffer text (UTF-8) into the provided buffer.
 * Handles gap buffer and multibyte encoding.
 * Returns the number of bytes written, or -1 on error.
 * `from` and `to` are character positions (not byte positions).
 */
extern int64_t neomacs_layout_buffer_text(EmacsBuffer buffer,
                                          int64_t from,
                                          int64_t to,
                                          uint8_t *outBuf,
                                          int64_t outBufLen);

/**
 * Get the character at a character position.
 * Returns the Unicode codepoint, or -1 if out of range.
 */
extern int32_t neomacs_layout_char_at(EmacsBuffer buffer, int64_t charpos);

/**
 * Get buffer narrowing bounds: BEGV and ZV (character positions).
 */
extern void neomacs_layout_buffer_bounds(EmacsBuffer buffer, int64_t *begv, int64_t *zv);

/**
 * Get buffer point position (character position).
 */
extern int64_t neomacs_layout_buffer_point(EmacsBuffer buffer);

/**
 * Check if buffer uses multibyte encoding.
 */
extern int neomacs_layout_buffer_multibyte_p(EmacsBuffer buffer);

/**
 * Get buffer-local tab-width.
 */
extern int neomacs_layout_buffer_tab_width(EmacsBuffer buffer);

/**
 * Get buffer-local truncate-lines setting.
 */
extern int neomacs_layout_buffer_truncate_lines(EmacsBuffer buffer);

/**
 * Get the number of leaf windows in the frame.
 */
extern int neomacs_layout_frame_window_count(EmacsFrame frame);

/**
 * Get window parameters for the Nth leaf window.
 * Fills the WindowParamsFFI struct. Returns 0 on success, -1 on error.
 */
extern int neomacs_layout_get_window_params(EmacsFrame frame,
                                            int windowIndex,
                                            struct WindowParamsFFI *params);

/**
 * Get the resolved face at a buffer position for a given window.
 * Returns face data in the FaceDataFFI struct.
 * This calls face_at_buffer_position() internally.
 * If next_check_out is non-null, writes the position where the face may change.
 */
extern int neomacs_layout_face_at_pos(EmacsWindow window,
                                      int64_t charpos,
                                      struct FaceDataFFI *faceOut,
                                      int64_t *nextCheckOut);

/**
 * Get the default face for a frame.
 */
extern int neomacs_layout_default_face(EmacsFrame frame, struct FaceDataFFI *faceOut);

/**
 * Set window_end_pos on an Emacs window (for window-end Lisp function).
 */
extern void neomacs_layout_set_window_end(EmacsWindow window, int64_t endPos, int endVpos);

/**
 * Set cursor position on an Emacs window.
 */
extern void neomacs_layout_set_cursor(EmacsWindow window, int x, int y, int hpos, int vpos);

/**
 * Trigger fontification at a position (calls fontification-functions).
 * Returns 1 if fontification happened, 0 if text was already fontified.
 */
extern int neomacs_layout_ensure_fontified(EmacsBuffer buffer, int64_t from, int64_t to);

/**
 * Check if text at charpos is invisible.
 * Returns 0 = visible, 1 = invisible (hidden), 2 = invisible (ellipsis).
 * If invisible, *next_visible_out is set to the next visible position.
 */
extern int neomacs_layout_check_invisible(EmacsBuffer buffer,
                                          EmacsWindow window,
                                          int64_t charpos,
                                          int64_t *nextVisibleOut);

/**
 * Get mode-line text for a window as plain UTF-8.
 * Returns the number of bytes written, or -1 on error.
 * Also fills face_out with the mode-line face (active or inactive).
 */
extern int64_t neomacs_layout_mode_line_text(EmacsWindow window,
                                             EmacsFrame frame,
                                             uint8_t *outBuf,
                                             int64_t outBufLen,
                                             struct FaceDataFFI *faceOut);

/**
 * Get header-line text for a window as plain UTF-8.
 * Returns the number of bytes written, 0 if no header-line, or -1 on error.
 * Also fills face_out with the header-line face (active or inactive).
 */
extern int64_t neomacs_layout_header_line_text(EmacsWindow window,
                                               EmacsFrame frame,
                                               uint8_t *outBuf,
                                               int64_t outBufLen,
                                               struct FaceDataFFI *faceOut);

/**
 * Get tab-line text for a window as plain UTF-8.
 * Returns the number of bytes written, 0 if no tab-line, or -1 on error.
 * Also fills face_out with the tab-line face.
 */
extern int64_t neomacs_layout_tab_line_text(EmacsWindow window,
                                            EmacsFrame frame,
                                            uint8_t *outBuf,
                                            int64_t outBufLen,
                                            struct FaceDataFFI *faceOut);

/**
 * Get line number display configuration for a window.
 * Returns 0 on success, -1 on error.
 */
extern int neomacs_layout_line_number_config(EmacsWindow window,
                                             EmacsBuffer buffer,
                                             int64_t bufferZv,
                                             int maxRows,
                                             struct LineNumberConfigFFI *configOut);

/**
 * Count the line number at a character position.
 * Returns the 1-based line number.
 */
extern int64_t neomacs_layout_count_line_number(EmacsBuffer buffer, int64_t charpos, int widen);

/**
 * Resolve the face for a line number and fill FaceDataFFI.
 */
extern int neomacs_layout_line_number_face(EmacsWindow window,
                                           int isCurrent,
                                           int64_t lnum,
                                           int majorTick,
                                           int minorTick,
                                           struct FaceDataFFI *faceOut);

/**
 * Check for a 'display text property at charpos.
 * Handles string replacement and space specs.
 * Writes replacement string into str_buf (type=1).
 * Fills DisplayPropFFI with type, length, and region end.
 * Returns 0 on success, -1 on error.
 */
extern int neomacs_layout_check_display_prop(EmacsBuffer buffer,
                                             EmacsWindow window,
                                             int64_t charpos,
                                             uint8_t *strBuf,
                                             int strBufLen,
                                             struct DisplayPropFFI *out);

/**
 * Collect overlay before-string and after-string at a position.
 * Before-strings come from overlays starting at charpos.
 * After-strings come from overlays ending at charpos.
 * Returns 0 on success, -1 on error.
 */
extern int neomacs_layout_overlay_strings_at(EmacsBuffer buffer,
                                             EmacsWindow window,
                                             int64_t charpos,
                                             uint8_t *beforeBuf,
                                             int beforeBufLen,
                                             int *beforeLenOut,
                                             uint8_t *afterBuf,
                                             int afterBufLen,
                                             int *afterLenOut,
                                             struct FaceDataFFI *beforeFaceOut,
                                             struct FaceDataFFI *afterFaceOut);

/**
 * Check if a character should display as a glyphless glyph.
 * Looks up Vglyphless_char_display char-table.
 * method_out: 0=normal, 1=thin_space, 2=empty_box, 3=hex_code,
 *             4=acronym, 5=zero_width.
 * For method=4 (acronym), writes the string into str_buf.
 */
extern int neomacs_layout_check_glyphless(EmacsFrame frame,
                                          int codepoint,
                                          int *methodOut,
                                          uint8_t *strBuf,
                                          int strBufLen,
                                          int *strLenOut);

/**
 * Collect margin overlay strings at a buffer position.
 * Checks overlay before/after-strings for (margin left-margin) and
 * (margin right-margin) display properties.
 */
extern int neomacs_layout_margin_strings_at(EmacsBuffer buffer,
                                            EmacsWindow window,
                                            int64_t charpos,
                                            uint8_t *leftBuf,
                                            int leftBufLen,
                                            int *leftLenOut,
                                            uint8_t *rightBuf,
                                            int rightBufLen,
                                            int *rightLenOut);

/**
 * Check line-height and line-spacing text properties at a position.
 * Returns extra height (pixels) beyond base_height for the row.
 */
extern int neomacs_layout_check_line_spacing(EmacsBuffer buffer,
                                             EmacsWindow window,
                                             int64_t charpos,
                                             float baseHeight,
                                             float *extraHeightOut);

/**
 * Check line-prefix or wrap-prefix text property at a position.
 * prefix_type: 0=line-prefix, 1=wrap-prefix
 * Returns prefix width in columns via width_out.
 * width_out = -1.0 means no override (use window default).
 */
extern int neomacs_layout_check_line_prefix(EmacsBuffer buffer,
                                            EmacsWindow window,
                                            int64_t charpos,
                                            int prefixType,
                                            float *widthOut);

#endif  /* NEOMACS_DISPLAY_H */
