/* Auto-generated by cbindgen. Do not edit. */
/* Neomacs Display Engine C FFI */


#ifndef NEOMACS_DISPLAY_H
#define NEOMACS_DISPLAY_H

/* Warning: this file was auto-generated by cbindgen. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define DRM_FORMAT_ARGB8888 875713089

#define DRM_FORMAT_XRGB8888 875713112

#define DRM_FORMAT_ABGR8888 875708993

#define DRM_FORMAT_XBGR8888 875709016

/**
 * Backend type selection
 */
typedef enum BackendType {
  /**
   * GTK4/GSK GPU-accelerated backend
   */
  BACKEND_TYPE_GTK4 = 0,
  /**
   * Terminal/TTY backend
   */
  BACKEND_TYPE_TTY = 1,
} BackendType;

/**
 * Initialize the display engine
 *
 * # Safety
 * Returns a pointer to NeomacsDisplay that must be freed with neomacs_display_shutdown.
 */
struct NeomacsDisplay *neomacs_display_init(enum BackendType backend);

/**
 * Shutdown the display engine
 *
 * # Safety
 * The handle must have been returned by neomacs_display_init.
 */
void neomacs_display_shutdown(struct NeomacsDisplay *handle);

/**
 * Resize the display
 */
void neomacs_display_resize(struct NeomacsDisplay *handle, int width, int height);

/**
 * Begin building a new frame
 */
void neomacs_display_begin_frame(struct NeomacsDisplay *handle);

/**
 * Add a window to the current frame
 */
void neomacs_display_add_window(struct NeomacsDisplay *handle,
                                int windowId,
                                float x,
                                float y,
                                float width,
                                float height,
                                uint32_t bgColor,
                                int selected);

/**
 * Set cursor for a specific window
 */
void neomacs_display_set_cursor(struct NeomacsDisplay *handle,
                                int windowId,
                                float x,
                                float y,
                                float width,
                                float height,
                                int style,
                                uint32_t color,
                                int visible);

/**
 * Draw a border rectangle (for window dividers)
 */
void neomacs_display_draw_border(struct NeomacsDisplay *handle,
                                 int x,
                                 int y,
                                 int width,
                                 int height,
                                 uint32_t color);

/**
 * Begin a new glyph row for the current window
 */
void neomacs_display_begin_row(struct NeomacsDisplay *handle,
                               int y,
                               int x,
                               int height,
                               int ascent,
                               int modeLine,
                               int headerLine);

/**
 * Add a character glyph to the current row
 */
void neomacs_display_add_char_glyph(struct NeomacsDisplay *handle,
                                    uint32_t charcode,
                                    uint32_t faceId,
                                    int pixelWidth,
                                    int ascent,
                                    int descent);

/**
 * Add a stretch (whitespace) glyph to the current row
 */
void neomacs_display_add_stretch_glyph(struct NeomacsDisplay *handle,
                                       int pixelWidth,
                                       int height,
                                       uint32_t faceId);

/**
 * Add an image glyph to the current row
 */
void neomacs_display_add_image_glyph(struct NeomacsDisplay *handle,
                                     uint32_t imageId,
                                     int pixelWidth,
                                     int pixelHeight);

/**
 * End the current row
 */
void neomacs_display_end_row(struct NeomacsDisplay *handle);

/**
 * Register or update a face
 * Colors are in 0xRRGGBB format
 */
void neomacs_display_set_face(struct NeomacsDisplay *handle,
                              uint32_t faceId,
                              uint32_t foreground,
                              uint32_t background,
                              const char *fontFamily,
                              uint16_t fontWeight,
                              int isItalic,
                              int underlineStyle,
                              uint32_t underlineColor,
                              int boxType,
                              uint32_t boxColor,
                              int boxLineWidth);

/**
 * Set the frame/scene background color
 * Color is in 0xRRGGBB format
 */
void neomacs_display_set_background(struct NeomacsDisplay *handle, uint32_t color);

/**
 * Add a video glyph to the current row
 */
void neomacs_display_add_video_glyph(struct NeomacsDisplay *handle,
                                     uint32_t videoId,
                                     int pixelWidth,
                                     int pixelHeight);

/**
 * Load a video from URI
 * Returns video_id on success, 0 on failure
 */
uint32_t neomacs_display_load_video(struct NeomacsDisplay *handle, const char *uri);

/**
 * Play a loaded video
 */
int neomacs_display_video_play(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Pause a video
 */
int neomacs_display_video_pause(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Stop a video
 */
int neomacs_display_video_stop(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Set video loop mode
 * count: -1 = infinite loop, 0 = no loop, n > 0 = loop n times
 * Returns 0 on success, -1 on failure
 */
int neomacs_display_video_set_loop(struct NeomacsDisplay *handle, uint32_t videoId, int loopCount);

/**
 * Update video frame (called from Emacs redisplay)
 * Returns 0 on success, -1 on failure
 */
int neomacs_display_video_update(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Load an image from a file path
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image(struct NeomacsDisplay *handle, const char *path);

/**
 * Load an image from raw bytes
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image_data(struct NeomacsDisplay *handle,
                                         const uint8_t *data,
                                         uintptr_t len);

/**
 * Load an image from raw bytes with optional scaling
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image_data_scaled(struct NeomacsDisplay *handle,
                                                const uint8_t *data,
                                                uintptr_t len,
                                                int maxWidth,
                                                int maxHeight);

/**
 * Load an image from raw ARGB32 pixel data (Cairo/Emacs format)
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image_argb32(struct NeomacsDisplay *handle,
                                           const uint8_t *data,
                                           int width,
                                           int height,
                                           int stride);

/**
 * Load an image from raw RGB24 pixel data (no alpha)
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image_rgb24(struct NeomacsDisplay *handle,
                                          const uint8_t *data,
                                          int width,
                                          int height,
                                          int stride);

/**
 * Load an image from a file path
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image_file(struct NeomacsDisplay *handle, const char *path);

/**
 * Load an image from a file path with scaling
 * If max_width or max_height is 0, that dimension is not constrained
 * Returns image_id on success, 0 on failure
 */
uint32_t neomacs_display_load_image_file_scaled(struct NeomacsDisplay *handle,
                                                const char *path,
                                                int maxWidth,
                                                int maxHeight);

/**
 * Get image dimensions
 * Returns 0 on success, -1 on failure
 */
int neomacs_display_get_image_size(struct NeomacsDisplay *handle,
                                   uint32_t imageId,
                                   int *width,
                                   int *height);

/**
 * Free an image from cache
 */
int neomacs_display_free_image(struct NeomacsDisplay *handle, uint32_t imageId);

/**
 * Set a floating video at a specific screen position
 * The video will be rendered on top of the frame
 */
void neomacs_display_set_floating_video(struct NeomacsDisplay *handle,
                                        uint32_t videoId,
                                        int x,
                                        int y,
                                        int width,
                                        int height);

/**
 * Remove a floating video
 */
void neomacs_display_clear_floating_video(struct NeomacsDisplay *handle, uint32_t videoId);

/**
 * Set a floating image at a specific screen position
 * The image will be rendered on top of the frame
 */
void neomacs_display_set_floating_image(struct NeomacsDisplay *handle,
                                        uint32_t imageId,
                                        int x,
                                        int y,
                                        int width,
                                        int height);

/**
 * Remove a floating image
 */
void neomacs_display_clear_floating_image(struct NeomacsDisplay *handle, uint32_t imageId);

/**
 * Clear a rectangular area of the display
 * Used by gui_clear_end_of_line and related functions
 */
void neomacs_display_clear_area(struct NeomacsDisplay *handle, int x, int y, int width, int height);

/**
 * Clear all glyphs - used when frame layout changes (e.g., tab-bar-mode toggle)
 */
void neomacs_display_clear_all_glyphs(struct NeomacsDisplay *handle);

/**
 * Clear all cursors - called at start of each frame to prevent ghost cursors
 * when focus changes between windows (e.g., buffer <-> minibuffer)
 */
void neomacs_display_clear_all_cursors(struct NeomacsDisplay *handle);

/**
 * Clear all borders (window dividers) - called at start of each frame
 * to prevent stale dividers when windows are deleted
 */
void neomacs_display_clear_all_borders(struct NeomacsDisplay *handle);

/**
 * End frame and render
 * Returns 0 on success, 1 if layout changed (Emacs should force refresh), -1 on error
 */
int neomacs_display_end_frame(struct NeomacsDisplay *handle);

/**
 * Render the scene to an external Cairo context
 *
 * # Safety
 * The cairo_context must be a valid cairo_t pointer from C.
 */
int neomacs_display_render_to_cairo(struct NeomacsDisplay *handle, void *cairoContext);

/**
 * Initialize the renderer with a Pango context (call after widget is realized)
 */
void neomacs_display_init_pango(struct NeomacsDisplay *handle, void *pangoContext);

/**
 * Enable or disable GSK rendering
 */
void neomacs_display_set_gsk_enabled(struct NeomacsDisplay *handle, int enabled);

/**
 * Start smooth scroll animation
 */
void neomacs_display_smooth_scroll(struct NeomacsDisplay *handle,
                                   int windowId,
                                   float fromOffset,
                                   float toOffset);

/**
 * Reset cursor blink (call when cursor moves)
 */
void neomacs_display_reset_cursor_blink(struct NeomacsDisplay *handle);

/**
 * Check if animations are active
 */
int neomacs_display_has_animations(struct NeomacsDisplay *handle);

/**
 * Get backend name
 */
const char *neomacs_display_backend_name(struct NeomacsDisplay *handle);

/**
 * Check if backend is initialized
 */
int neomacs_display_is_initialized(struct NeomacsDisplay *handle);

/**
 * Create a GPU-accelerated NeomacsWidget
 *
 * # Safety
 * Returns a pointer to a NeomacsWidget that can be added to a GTK container.
 * The widget is owned by GTK's reference counting system.
 */
void *neomacs_display_create_widget(void);

/**
 * Set the scene on a NeomacsWidget (triggers GPU-accelerated redraw)
 *
 * # Safety
 * handle must be a valid NeomacsDisplay pointer
 * widget must be a valid NeomacsWidget pointer
 */
int neomacs_display_widget_set_scene(struct NeomacsDisplay *handle, void *widget);

/**
 * Initialize the GSK renderer's Pango context from a NeomacsWidget
 *
 * # Safety
 * handle must be valid, widget must be a realized NeomacsWidget
 */
void neomacs_display_widget_init_pango(struct NeomacsDisplay *handle, void *widget);

/**
 * Render scene to a NeomacsWidget using GSK (GPU-accelerated)
 *
 * This renders directly using GSK render nodes for GPU acceleration.
 *
 * # Safety
 * handle must be valid, widget must be a valid NeomacsWidget
 */
int neomacs_display_render_to_widget(struct NeomacsDisplay *handle, void *widget);

/**
 * Set the resize callback for the NeomacsWidget
 * The callback will be called whenever the widget is resized
 */
void neomacs_display_set_resize_callback(ResizeCallbackFn callback, void *userData);

/**
 * Set the mouse button callback for the NeomacsWidget
 * Called on button press (pressed=1) and release (pressed=0)
 */
void neomacs_display_set_mouse_button_callback(MouseButtonCallbackFn callback, void *userData);

/**
 * Set the mouse motion callback for the NeomacsWidget
 * Called on mouse movement
 */
void neomacs_display_set_mouse_motion_callback(MouseMotionCallbackFn callback, void *userData);

/**
 * Set the mouse scroll callback for the NeomacsWidget
 * Called on scroll wheel events
 */
void neomacs_display_set_mouse_scroll_callback(MouseScrollCallbackFn callback, void *userData);

/**
 * Set callback for WebKit new window/tab requests (target="_blank", window.open(), etc.)
 * Pass null to clear the callback.
 */
void neomacs_display_webkit_set_new_window_callback(Option<WebKitNewWindowCallback> callback);

void neomacs_display_webkit_set_new_window_callback(bool (*callback)(uint32_t,
                                                                     const char*,
                                                                     const char*));

/**
 * Initialize WebKit subsystem with EGL display
 * Must be called before creating WebKit views
 */
int neomacs_display_webkit_init(struct NeomacsDisplay *handle, void *eglDisplay);

/**
 * Create a new WebKit view
 * Returns view_id on success, 0 on failure
 */
uint32_t neomacs_display_webkit_create(struct NeomacsDisplay *handle, int width, int height);

/**
 * Destroy a WebKit view
 */
int neomacs_display_webkit_destroy(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Load a URI in a WebKit view
 */
int neomacs_display_webkit_load_uri(struct NeomacsDisplay *handle,
                                    uint32_t viewId,
                                    const char *uri);

/**
 * Go back in a WebKit view
 */
int neomacs_display_webkit_go_back(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Go forward in a WebKit view
 */
int neomacs_display_webkit_go_forward(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Reload a WebKit view
 */
int neomacs_display_webkit_reload(struct NeomacsDisplay *handle, uint32_t viewId);

/**
 * Execute JavaScript in a WebKit view
 */
int neomacs_display_webkit_execute_js(struct NeomacsDisplay *handle,
                                      uint32_t viewId,
                                      const char *script);

/**
 * Set a floating WebKit view position and size
 */
void neomacs_display_set_floating_webkit(struct NeomacsDisplay *handle,
                                         uint32_t webkitId,
                                         int x,
                                         int y,
                                         int width,
                                         int height);

/**
 * Hide a floating WebKit view
 */
void neomacs_display_hide_floating_webkit(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Send keyboard event to WebKit view
 */
void neomacs_display_webkit_send_key(struct NeomacsDisplay *handle,
                                     uint32_t webkitId,
                                     uint32_t keyCode,
                                     uint32_t hardwareKeyCode,
                                     int pressed,
                                     uint32_t modifiers);

/**
 * Send pointer/mouse event to WebKit view
 */
void neomacs_display_webkit_send_pointer(struct NeomacsDisplay *handle,
                                         uint32_t webkitId,
                                         uint32_t eventType,
                                         int x,
                                         int y,
                                         uint32_t button,
                                         uint32_t state,
                                         uint32_t modifiers);

/**
 * Send scroll event to WebKit view
 */
void neomacs_display_webkit_send_scroll(struct NeomacsDisplay *handle,
                                        uint32_t webkitId,
                                        int x,
                                        int y,
                                        int deltaX,
                                        int deltaY);

/**
 * Click in WebKit view (convenience function)
 */
void neomacs_display_webkit_click(struct NeomacsDisplay *handle,
                                  uint32_t webkitId,
                                  int x,
                                  int y,
                                  uint32_t button);

/**
 * Get WebKit view title (returns null-terminated string, caller must free)
 */
char *neomacs_display_webkit_get_title(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Get WebKit view URL (returns null-terminated string, caller must free)
 */
char *neomacs_display_webkit_get_url(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Get WebKit view loading progress (0.0 - 1.0), returns -1 if view not found
 */
double neomacs_display_webkit_get_progress(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Check if WebKit view is loading (1=loading, 0=not loading, -1=not found)
 */
int neomacs_display_webkit_is_loading(struct NeomacsDisplay *handle, uint32_t webkitId);

/**
 * Free a string returned by webkit_get_title or webkit_get_url
 */
void neomacs_display_webkit_free_string(char *s);

/**
 * Add a WPE glyph to the current row
 */
void neomacs_display_add_wpe_glyph(struct NeomacsDisplay *handle,
                                   uint32_t viewId,
                                   int pixelWidth,
                                   int pixelHeight);

/**
 * Set an animation configuration option
 *
 * key: option name (e.g., "animation", "cursor-animation", "cursor-animation-mode", etc.)
 * value: option value (e.g., "t", "nil", "railgun", "crossfade", "30", etc.)
 *
 * Returns 1 on success, 0 on failure
 */
int neomacs_display_set_animation_option(struct NeomacsDisplay *handle,
                                         const char *key,
                                         const char *value);

/**
 * Get an animation configuration option
 *
 * Returns the value as a newly-allocated C string (caller must free with neomacs_display_free_string)
 * Returns NULL on failure or unknown option
 */
char *neomacs_display_get_animation_option(struct NeomacsDisplay *handle,
                                           const char *key);

/**
 * Free a string returned by neomacs_display_get_animation_option
 */
void neomacs_display_free_string(char *s);

/**
 * Update cursor animation state (call each frame from GTK widget)
 *
 * dt: delta time in seconds since last frame
 * Returns 1 if animation is still in progress (needs redraw), 0 otherwise
 */
int neomacs_display_update_animation(struct NeomacsDisplay *handle, double dt);

/**
 * Check if animation needs continuous redraw
 * Returns 1 if continuous redraw needed, 0 otherwise
 */
int neomacs_display_animation_active(struct NeomacsDisplay *handle);

/**
 * Trigger a buffer transition animation
 *
 * effect: transition effect name ("crossfade", "slide-left", "slide-right", etc.)
 * duration: animation duration in milliseconds
 * Returns 1 on success, 0 on failure
 */
int neomacs_display_start_buffer_transition(struct NeomacsDisplay *handle,
                                            const char *effect,
                                            int durationMs);

/**
 * Prepare for buffer transition (capture snapshot before buffer changes)
 * Call this BEFORE switching buffers
 * Returns 1 on success, 0 on failure
 */
int neomacs_display_prepare_buffer_transition(struct NeomacsDisplay *handle);

/**
 * Trigger buffer transition animation (after buffer has changed)
 * Call this AFTER switching buffers
 * Returns 1 on success, 0 on failure
 */
int neomacs_display_trigger_buffer_transition(struct NeomacsDisplay *handle);

/**
 * Check if buffer transition is ready (has snapshot)
 * Returns 1 if ready, 0 if not
 */
int neomacs_display_has_transition_snapshot(struct NeomacsDisplay *handle);

#endif  /* NEOMACS_DISPLAY_H */
