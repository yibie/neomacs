1	(let ((m (make-sparse-keymap))) (define-key m (kbd "M-x") 'ignore) (lookup-key m (kbd "M-x")))	OK ignore
2	(let ((m (make-sparse-keymap))) (define-key m [134217848] 'ignore) (lookup-key m [134217848]))	OK ignore
3	(let ((m (make-sparse-keymap))) (define-key m "M-x" 'ignore) (lookup-key m "M-x"))	OK ignore
4	(condition-case err (let ((m (make-sparse-keymap))) (define-key m 1 'ignore)) (error err))	OK (wrong-type-argument arrayp 1)
5	(condition-case err (let ((m (make-sparse-keymap))) (lookup-key m 1)) (error err))	OK (wrong-type-argument arrayp 1)
6	(let ((m (make-sparse-keymap))) (use-global-map m) (define-key m (kbd "M-x") 'ignore) (key-binding (kbd "M-x")))	OK ignore
7	(let ((m (make-sparse-keymap))) (use-global-map m) (define-key m (kbd "M-x") 'ignore) (global-key-binding (kbd "M-x")))	OK ignore
8	(let ((m (make-sparse-keymap))) (use-local-map m) (define-key m (kbd "M-x") 'ignore) (local-key-binding (kbd "M-x")))	OK ignore
9	(condition-case err (key-binding 1) (error err))	OK (wrong-type-argument arrayp 1)
10	(condition-case err (global-key-binding 1) (error err))	OK (wrong-type-argument arrayp 1)
11	(use-local-map nil)	OK nil
12	(condition-case err (local-key-binding 1) (error err))	OK nil
13	(let ((m (make-sparse-keymap))) (use-local-map m) (condition-case err (local-key-binding 1) (error err)))	OK (wrong-type-argument arrayp 1)
