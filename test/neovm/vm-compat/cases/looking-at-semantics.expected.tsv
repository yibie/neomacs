1	(fboundp 'looking-at)	OK t
2	(with-temp-buffer (insert "hello") (goto-char (point-min)) (looking-at "hel"))	OK t
3	(with-temp-buffer (insert "hello") (goto-char (point-min)) (looking-at "world"))	OK nil
4	(with-temp-buffer (insert "hello") (goto-char (point-min)) (looking-at "h\\(el\\)") (list (match-beginning 0) (match-end 0) (match-beginning 1) (match-end 1)))	OK (1 4 2 4)
5	(with-temp-buffer (insert "hello") (goto-char (point-min)) (set-match-data (list 7 8)) (looking-at "world") (match-data))	OK (7 8)
6	(with-temp-buffer (insert "A") (goto-char (point-min)) (let ((case-fold-search nil)) (looking-at "a")))	OK nil
7	(with-temp-buffer (insert "A") (goto-char (point-min)) (let ((case-fold-search nil)) (looking-at-p "a")))	OK nil
8	(with-temp-buffer (insert "A") (goto-char (point-min)) (looking-at-p "a"))	OK t
9	(with-temp-buffer (insert "a") (goto-char (point-min)) (let ((case-fold-search t)) (looking-at "A")))	OK t
10	(with-temp-buffer (insert "a") (goto-char (point-min)) (let ((case-fold-search t)) (looking-at-p "A")))	OK t
11	(condition-case err (looking-at "[") (invalid-regexp (car err)))	OK invalid-regexp
12	(condition-case err (looking-at) (wrong-number-of-arguments (car err)))	OK wrong-number-of-arguments
13	(condition-case err (looking-at 1) (error err))	OK (wrong-type-argument stringp 1)
