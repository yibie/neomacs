1	(minor-mode-key-binding "a")	OK nil
2	(minor-mode-key-binding [])	OK nil
3	(condition-case err (minor-mode-key-binding 1) (error err))	OK nil
4	(let* ((m (make-sparse-keymap))) (define-key m (kbd "C-a") #'ignore) (let ((minor-mode-map-alist (list (cons 'demo-mode m))) (demo-mode t)) (minor-mode-key-binding (kbd "C-a"))))	OK ((demo-mode . ignore))
5	(let* ((m1 (make-sparse-keymap)) (m2 (make-sparse-keymap))) (define-key m1 (kbd "C-a") #'ignore) (define-key m2 (kbd "C-a") #'forward-char) (let ((minor-mode-map-alist (list (cons 'mode1 m1) (cons 'mode2 m2))) (mode1 t) (mode2 t)) (minor-mode-key-binding (kbd "C-a"))))	OK ((mode1 . ignore))
6	(let ((minor-mode-map-alist '((demo-mode . 999999))) (demo-mode t)) (condition-case err (minor-mode-key-binding (kbd "C-a")) (error err)))	OK (wrong-type-argument keymapp 999999)
7	(condition-case err (minor-mode-key-binding) (error err))	OK (wrong-number-of-arguments minor-mode-key-binding 0)
8	(condition-case err (minor-mode-key-binding "a" t 'extra) (error err))	OK (wrong-number-of-arguments minor-mode-key-binding 3)
