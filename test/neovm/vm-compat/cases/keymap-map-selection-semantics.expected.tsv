1	(fboundp 'current-global-map)	OK t
2	(fboundp 'current-local-map)	OK t
3	(fboundp 'use-global-map)	OK t
4	(fboundp 'use-local-map)	OK t
5	(condition-case err (keymapp (current-global-map)) (error err))	OK t
6	(condition-case err (current-local-map) (error err))	OK nil
7	(condition-case err (let ((m (make-sparse-keymap))) (use-local-map m) (equal (current-local-map) m)) (error err))	OK t
8	(condition-case err (progn (use-local-map nil) (current-local-map)) (error err))	OK nil
9	(condition-case err (let ((m (make-sparse-keymap))) (use-global-map m) (equal (current-global-map) m)) (error err))	OK t
10	(condition-case err (current-global-map nil) (error (car err)))	OK wrong-number-of-arguments
11	(condition-case err (current-local-map nil) (error (car err)))	OK wrong-number-of-arguments
12	(condition-case err (use-global-map) (error (car err)))	OK wrong-number-of-arguments
13	(condition-case err (use-local-map) (error (car err)))	OK wrong-number-of-arguments
