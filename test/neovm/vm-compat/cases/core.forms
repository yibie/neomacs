; Basic arithmetic and list mutation behavior
(+ 1 2)
(let ((x 1)) (setq x (+ x 2)) x)
(let ((lst '(1 2))) (setcar lst 9) lst)

; Control flow and error behavior
(catch 'tag (throw 'tag 42))
(condition-case e (/ 1 0) (arith-error 'div-zero))

; Dynamic-binding-sensitive shape (lexical-binding=nil in this oracle)
(let ((x 1))
  (let ((f (lambda () x)))
    (let ((x 2))
      (funcall f))))

; Function namespace and core list/branch primitives
(progn
  (defun add2 (a b) (+ a b))
  (add2 5 7))
(if (eq (car (cons 1 nil)) 1) (list 9 8) nil)
(cdr '(1 2 3))
(if nil 1 2)
